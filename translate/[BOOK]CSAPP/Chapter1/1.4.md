## Processors Read and Interpret Instructions Stored in Memory

컴파일 시스템에 의해 실행파일로 만들어진 hello.c를 유닉스시스템에서 실행시킬려면 다음과 같은 커맨드를 쉘이라 불리는 애플리케이션 프로그램에 입력하면된다.

``` shell
linux> ./hello
hello,world
linux>
```

쉘은 프롬프트를 출력하는 커맨드라인 인터프리터다. 사용자가 커맨드 라인을 입력할 때 까지 기다리고, 커맨드를 실행한다.

만약, 커맨드의 첫 단어가 쉘 기본 커맨드가 아닌 경우, 자신이 로드하고 실행해야 할 파일로 취급한다. 그래서 이 경우에는 hello 프로그램이 로드 되고, 실행되며, 끝날 때 까지 기다린다.

헬로 프로그램은 메시지를 화면에 출력한 후 종료한다. 그러고나서, 프롬프트를 출력하고 다음 입력이 들어올 때 까지 기다린다.

> 프롬프트? <br>
> 프롬프트는 컴퓨터 터미널의 CLI의 명령줄 대기모드를 가리킨다. [위키피디아](https://ko.wikipedia.org/wiki/명령_프롬프트)

## 1.4.1 시스템의 하드웨어 구성

![hardwareOrganizationOfASystem](https://user-images.githubusercontent.com/42995061/95584876-5814a280-0a79-11eb-9ccb-d0401669e294.png)

hello 프로그램이 실행될 때 무슨 일이 벌어지는지 이해하기 위해선, 일반적인 ***시스템의 하드웨어*** 구성에 대한 이해가 필요하다.

이 사진은 최신 인텔 시스템을 본떠서 모델링한 것이다.

*(현재 번역중인 이 책은 CS:APP 3rd edition, 2016년도임)*

하지만 모든 시스템들은 비슷한 모양, 비슷한 느낌을 갖고있다. 이 사진의 복잡성에 대해 지금은 걱정말자. 

이 책의 코스내내 단계적으로 이 사진의 다양한 세부사항들에 대해 접근하고, 도달할 것이다.

---

## Buses

시스템 전체에 걸쳐 구동되는 건 *구성요소간 바이트 정보를 여기저기 주고받는*  ***버스***라 불리는 전기 도관들이다.

일반적으로, 버스는 words라 불리는 고정된 크기의 바이트 청크(fixed-size chunks of bytes)를 전송하게끔 설계 됐다.

> 워드? <br>
> CPU가 한번에 처리하는 데이터의 크기, 데이터의 최소 연산 단위이다. [위키피디아](https://ko.wikipedia.org/wiki/워드_(컴퓨팅))

워드의 바이트 수는 시스템마다 달라지는, 기본 시스템 한도이다.

오늘날, 대부분의 머신은 워드 사이즈가 4바이트(32비트) 혹은 8바이트(64비트)이다.

이 책에선, 워드 사이즈를 어떠한 고정된 것으로 가정하지 않고, 우리가 나중에 구체적으로 알려줄(명시할) 것이다. 어떤 맥락속에서 이게 정의되어야 하는 상황이 오게된다면 말이다.

## I/O Drivers

I/O 디바이스는 바깥 세상과 통하는 시스템의 연결점이다.

우리의 예제 시스템(위의 사진)은 4개의 I/O 디바이스를 갖고 있다.
- 키보드, 마우스 - (사용자 인풋을 위함)
- 디스플레이 - (아웃풋을 위함)
- 디스크 드라이브(혹은 단순하게 디스크) - (데이터와 프로그램을 장기보관)

처음에 hello프로그램은 디스크에 있다.

각각의 I/O 디바이스는 컨트롤러 혹은 어댑터에 의해 I/O 버스로 연결된다.

컨트롤러와 어댑터간 구별은 주로 포장의 차이다.

컨트롤러는 디바이스에 칩셋이 있거나, 시스템의 메인PCB에 있다. (마더보드라 부르는 그것)

반면, 어댑터는 마더보드의 슬롯에 끼는 카드이다.

어쨌건 컨트롤러와 어댑터의 목적은 I/O 버스와 I/O 디바이스간의 정보 전달이다.

이 책의 챕터 6과 10에서 좀 더 자세히 다룰 것이다.

6에서는 I/O 디바이스(여기서는 디스크)가 어떻게 작동하는지 말을 할 것이고,
10에서는 내 응용 프로그램에서 디바이스에 접근하기 위해 Unix I/O 인터페이스를 사용하는 법을 알려줄 것이다.

우린 네트워크라 알려진 흥미로운 디바이스의 종류에 초점을 맞추고있다.

하지만, 이 테크닉들은 다른 디바이스에도 일반화된다.

*I/O 디바이스들을 다루는 테크닉(기법)은 일반화 되있다는 말*

## Main Memory

메인 메모리는 프로세서가 프로그램을 실행하는 동안, 프로그램과 프로그램이 사용하는 데이터를 저장하는 임시 저장 디바이스다.

물리적으로, 메인메모리는 동적 임의 접근 메모리(DRAM, dynamic random access memory)의 집합체로 이루어져있다.

논리적으로, 메모리는 0부터 시작하는(array index) 각각의 고유 주소를 갖고 있는 바이트의 선형 배열로 구성되어 있다. 

보편적으로, 프로그램을 구성하는 각각의 기계어는 가변바이트 수로 이루어질 수 있다.

(기계어마다 바이트의 수가 variable하다는 뜻인듯)

C 프로그램 변수에 해당하는 데이터 아이템의 사이즈는 타입에 따라 결정된다.

예를 들어, 리눅스에서 실행되는 x86-64 머신은 short 타입은 2바이트가 필요하고, int와 float는 4바이트가 필요하며, long과 double은 8바이트다.

챕터6에서는 DRAM 칩 작동방식과 메인메모리 형태로 결합(combine)하는건 어떻게 하는지에 관한 메모리 기술들에 대해 말할 것이다.

## Processor

CPU, 간단히 프로세서라 불리는 이것은 메인 메모리에 보관되어 있는 명령어들을 해석(혹은 실행)하는 엔진이라 볼 수 있다.

CPU 코어에는 프로그램 카운터(PC)라 부르는 워드사이즈의 저장 디바이스(혹은 레지스터)가 있다.

또한, PC는 언제든지 메인 메모리에 있는 기계어 명령의 주소를 포함한다.

컴퓨터가 켜지고 꺼지는 순간까지, 프로세서는 프로그램 카운터에 의해 지정된 명령어를 반복해서 실행하고, 프로그램 카운터는 다음 명령어를 지정하는 업데이트를 한다.

프로세서는 ISA(명령어 집합, Instruction Set Architecture)에 의해 정의된 매우 간단한 명령어 실행 모델에 따라 작동되는 것으로 보인다.

예제의 모델에서, 명령어들은 엄격한 순서로 실행되고, 단일 명령어 실행은 일련의 단계를 수행하는 걸 포함한다.

프로세서는 프로그램 카운터가 가리킨 메모리에서 명령어를 읽고, 명령어속에 있는 비트들을 해석하며, 지시된 몇가지 간단한 연산을 수행한다.

그러고나서, 다음 명령어를 가리키기 위해서 프로그램 카운터를 업데이트 시킨다. (이전에 실행된 명령어와 메모리 위치상으로 붙어있을 수 도, 아닐 수 도 있다.)

---

몇가지 간단한 연산이 있고, 이 연산들은 메인 메모리, 레지스터 파일, ALU 주위를 돈다.

레지스터 파일은 ***각 고유 이름을 가진, 워드사이즈 규격의 레지스터들의 집합체***인 작은 저장소다.

ALU는 새 데이터와 주소 값을 계산한다.

다음은 CPU가 명령어의 요청을 수행할 수 있는 간단한 연산의 일부 예제다.

- Load(불러오기) - 메인 메모리로부터 바이트와 워드를 레지스터로 복사하며, 레지스터의 이전 내용을 덮어쓴다.
- Store(저장) - 레지스터로부터 바이트와 워드를 메인 메모리의 특정 위치로 복사하며, 특정 위치의 이전 값을 덮어쓴다.
- Operate(연산) - 두 레지스터의 내용을 ALU로 복사하며, 두 워드의 산술 연산을 수행한다. 그리고 레지스터에 결과를 덮어쓰고, 저장한다.
- Jump(점프) - 명령어 혼자로부터 워드를 추출하고, 프로그램 카운터로 복사하며, PC의 이전 값을 덮어쓴다.

프로세서는 ISA의 단순 구현체로 보인다고 말했지만, 사실 현대의 프로세서는 프로그램 실행의 속도를 높이기 위해 더 복잡한 메커니즘을 사용하고있다.

따라서 우리는 프로세서의 ISA를, 각각의 기계어 명령어의 효과를 기술하며, 프로세서가 실제로 구현되는 방법을 풀어놓은 마이크로 아키텍처와 구별할 수 있다.

그래서 기계어에 대해 공부하게 될 때(챕터3), 기계의 ISA에 의해 제공된 추상화를 고려할 것이다.

챕터4에서는 프로세서가 정확히 어떻게 구현되었는지에 대해 말할 것이고, 챕터 5에서는 기계어 프로그램의 성능을 예측하고, 최적화 하는 최신 프로세서의 작동방식에 대한 모델을 설명할 것이다.

---

## 1.4.2 Running the hello Program

시스템의 하드웨어 구성과 연산에 대한 큰 그림이 주어졌으므로, 우리는 비로소 우리가 작성했던 프로그램이 실행되면 무슨 일이 생기는지 알 수 있어졌다.

우리는 나중에 세부 지식을 채워 넣을 것이기 때문에 꽤 많은 단계가 스킵될 것지만, 지금은 큰 그림으로 만족해 할 것이다.

처음 쉘 프로그램은 명령어를 입력하기 위해 우리를 기다리고, 쉘에 우리가 명령한 명령어를 실행한다.

우리가 ./hello라는 문자를 키보드에서 치면, 쉘 프로그램은 각각 하나하나를 레지스터와 메모리에 저장한다. 그림 1.5에 나온 것처럼 말이다.

그리고 엔터키를 누르면, 쉘은 그제서야 명령 입력이 완료됐음을 인식한다. 그렇게되면 쉘은 디스크에 있는 hello object file을 메인 메모리로, ***'코드와 데이터를' 복사하는 일련의 명령어를 실행***하여 executable hello file을 로드한다. 이 데이터에는 곧 출력될 hello, world\n이라는 문자열이 포함되어 있다.

DMA이라 알려진 테크닉을 사용해, 데이터는 프로세서의 개입없이 디스크에서 메인메모리로 KTX직행을 탈 수 있다. 이건 그림 1.6에 나와있다.

메모리에 hello 오브젝트 파일의 코드와 데이터가 로드되면, 프로세서는 hello 프로그램의 메인 루틴에 있는 기계어 명령어를 실행하기 시작한다. 이 명령어들은 hello,world\n이라는 문자열 byte를 메모리에서 레지스터 파일로 copy하는 것이며, 레지스터 파일에서 디스플레이 장치로, 화면에 디스플레이된다. 이건 그림 1.7에 나와있다.

---
## 그림들 (1.5 ~ 1.7)

### 1.5 (키보드 입력을 통해 메모리와 레지스터 파일로 저장되는 문자열)

![1 5](https://user-images.githubusercontent.com/42995061/95602759-54404a80-0a90-11eb-85e8-5cf6b6910e78.png)

### 1.6 (디스크에 있는 실행 파일을 메인 메모리로 불러들이기)

![1 6](https://user-images.githubusercontent.com/42995061/95602884-881b7000-0a90-11eb-8485-b6f2e8dad287.png)

### 1.7 (디스플레이로 출력 문자열 쓰기)

![1 7](https://user-images.githubusercontent.com/42995061/95602952-9bc6d680-0a90-11eb-9e0b-4628fff8e810.png)
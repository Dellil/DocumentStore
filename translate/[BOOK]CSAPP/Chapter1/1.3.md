## It Pays to Understand How Compilation Systems Work

hello.c 같은 간단한 프로그램은, 컴파일 시스템에 의존해 정확하고 효율적인 기계어를 만들 수 있다.

하지만, 프로그래머가 컴파일 시스템의 작동원리를 알아야 하는 중요한 이유는...

## 프로그램 퍼포먼스 최적화

최신 컴파일러들은 보통 질 좋은 코드를 생산하는 정교한(복잡한) 도구들이다.

프로그래머입장에서 효율 좋은 코드를 작성하기 위해 컴파일러의 내부 작동원리는 알 필요없다.

하지만, 우리의 C 프로그램이 좋은 방향으로 나아가기 위해서는 머신레벨 코드와 컴파일러는 각기 다른 C 코드조각들을 어떻게 머신코드로 번역하는지, 이 둘의 기본적인 지식이 필요하다.

예를 들어,
- switch문은 if-else 여러개를 떡칠한 것보다 ***항상*** 효율적인가?
- 함수 호출에 의해 얼마나 많은 오버헤드가 발생하는가?
- while 루프는 for 루프보다 더 효율적인가?
- 참조로 전달되는 인자보다 지역 변수로 더해가는게 왜 더 빠른가?
- 산술연산에서 괄호를 재배열했을뿐인데, 왜 함수가 더 빨리 실행되는 것인가?

챕터3에서, x86-64를 다룰것입니다.
컴파일러가 c 코드를 어떻게 x86-64로 나타내는지 알아볼 것입니다.

챕터 5에서, 컴파일러가 작업을 잘 수행할 수 있도록 C코드를 간단하게 변화시키는, C 프로그램 성능 튜닝에 대해 배우게 될 것입니다.

챕터 6에서, 메모리시스템의 계층적 성질, 어떻게 C 컴파일러가 메모리에 데이터 배열을 저장하는지, 어떻게 내 C 프로그램이 이 지식(메모리시스템)을 이용해 더 효율적으로 실행하는지

## 링크할때 일어나는 에러에 대한 이해
우리의 경험상, 가장 당혹스러운 프로그래밍 에러중 일부는 링커 연산과 관계가 있습니다. 특히 규모가 큰 소프트웨어 시스템을 빌드하려고 시도할때 발생한다.

간단한 예로, 
- 참조를 해결할 수 없다는 에러는 뭘 의미하는 것인가? 
- static 변수와 global 변수의 차이는 무엇인가?
- 같은 이름의 글로벌 변수가 각각 다른 C 파일에 있을 때, 어떤 일이 일어나는가?
- 정적 라이브러리와 동적 라이브러리의 차이는 무엇인가?
- CLI에 라이브러리 순서를 나열하는게 중요한 이유는 무엇인가?
- 가장 무서운 것으로 왜 링커와 연관된 에러는 실행하는 시간 전까지 나타나지 않는 것인가?

이런 질문에 대한 답은 챕터 7에서 배울 수 있습니다.

## 보안 취약점 돌파하기
많은 기간동안, 버퍼오버 플로우 취약점들은 네트워크와 인터넷 서버의 보안 취약점으로 여겨져 왔습니다.

이 취약점들은 신뢰할 수 없는 출처에서 오는 데이터의 양과 그 형태를 제한할 필요성을 느끼는 프로그래머가 너무나도 적었기 때문에 존재해왔습니다.

보안 프로그래밍의 첫 단계는 프로그램 스택에 저장되는 데이터와 제어 정보를 이해하는 것이다.

챕터 3에서는 어셈블리어를 study하는 기념으로, 스택 규율과 버퍼오버플로우 취약점에 대해 다룰 것입니다.

또한, 공격을 줄이기 위해, 프로그래머, 컴파일러, OS가 사용하는 방법들을 알아볼 것입니다.
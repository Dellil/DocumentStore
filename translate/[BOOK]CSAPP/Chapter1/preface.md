# Preface
이 책 (CS:APP로 알려져 있음)은 컴퓨터 과학자, 컴퓨터 엔지니어 그리고 컴퓨터 시스템의 **"안쪽"** 을 들여다 봄으로써 좋은 프로그램을 작성하고자 하는 사람들을 위해 쓰여졌습니다.

우리의 목표는 모든 컴퓨터 시스템의 뼈대가 되는 불변의 법칙들을 설명하고, 나아가서 하려는 건, 이런 것들이 어떻게 내 프로그램의 정확성, 퍼포먼스, 유틸리티에 관해 영향을 끼치는지 자세히 보여주고 싶었습니다.

수 많은 시스템 책들은 설계자의 시각(build's perspective)에서 쓰여졌습니다. 

대개, 하드웨어나 시스템 소프트웨어, OS, 컴파일러 그리고 네트워크 인터페이스 같은 것들을 어떻게 만드는지 설명하죠

하지만 이 책은 프로그래머의 시각에서 쓰여졌습니다. 애플리케이션 프로그래머들로 하여금, 위에서 말한 것들의 지식을 어떻게 사용하면 더 나은 프로그램을 작성하는지 설명을 해줍니다.

물론 시스템에 관해 배우는 것은, 시스템을 어떻게 만드는지 배우는 것에 좋은 한 걸음을 제공한다는 점에서, 이 책은 시스템 하드웨어와 소프트웨어 구현에 나서는 사람들에게 귀중한 안내책자 역할을 해줍니다.

많은 시스템 책들은 시스템의 한 측면, 그러니까 예를 들면 하드웨어의 구조, OS, 컴파일러, 네트워크등에 주목을 하는 경향이 있지만, 

이 책은 모든 영역에 발을 담가봅니다. 프로그래머의 시각이라는 컨셉으로 말이죠

만약 당신이 이 책을 통해 위의 컨셉(시스템)을 공부하고 깨닫게 된다면 미래에 당신은 초-프로그래머가 되어 있을 겁니다. 

고장났을 때 어떻게 고쳐야 할 지를 알고, 어떻게 작동하는지 아는 사람을 뜻하죠.

그리고, 이런 능력들이 길러질겁니다.
1. OS와 시스템 소프트웨어가 제공해주는 기능을 더 잘 활용할줄 알고
2. 광범위한 작동조건과 런타임 파라미터를 가로질러 정확하게 작동하며
3. 실행시간이 빠르고
4. 프로그램을 사이버공격에 취약하게 만드는 결함을 방지하는 프로그램을 작성하게 됩니다.

컴파일러, 아키텍처, OS, 임베디드, 네트워킹 및 사이버보안과 같은 고-급주제에 더 깊이 파고들 준비가 될겁니다.

## 독자의 배경지식 가정
이 책은 x86-64 기계어 코드를 실행하는 시스템에 중점을 뒀습니다.
x86-64는 1978년 8086 마이크로 프로세서로 시작한 인텔과 그 경쟁사의 기술 경쟁과정에서 생겨난 최신 산물입니다.

인텔이 자기의 마이크로프로세서 라인에 붙이는 네이밍 컨벤션때문에 이 종류의 마이크로 프로세서는 x86이라 불립니다.

반도체 기술이 진화를 이루게 되어서 하나의 칩에 더 많은 트랜지스터를 꼴박할 수 있게 되었습니다. 그 덕분에 프로세서는 컴퓨팅 파워와 메모리 수용력이 더 많아졌죠

이 진행과정 중, 16비트로 돌아가던 것이 IA32프로세서로 32비트로 그리고 가장 최근에는 x86-64덕분에 64비트로 돌아가게끔 변화했습니다.

이 머신들이 어떻게 리눅스에서 C 프로그램들을 실행하는지를 고려했습니다.
(대충 리눅스에 대한 설명 글)

C 프로그래밍 배경지식이 얇팍하거나 없으신 분들을 위해서 특별한 주석을 포함했습니다.

이 주석은 C에서 특히나 중요한 특징을 강조하기 위해서 한 것이며, 당신이 C++ 혹은 Java에 익숙하다고 가정했습니다.

본문에는 리눅스에서 컴파일하고 실행한 많은 프로그래밍 예제들이 있습니다. 
그래서 우리는 <i>너</i>가 리눅스를 사용하고 로그인 할 줄 알며, 파일 나열, 경로 변경과 같은 행동을 할 수 있을거라 가정했습니다! 

Windows 쓰시면... 아시죠?

또한, 저희는 당신이 C 혹은 C++에 좀 친숙할 것이라 가정했습니다.

하지만 Java만 다룰 줄 안다면, 전환하는데 조금 많은 노오력이 들것입니다.

이 책 초장의 몇몇 군데는 C와 기계어 사이의 상호작용을 살펴 볼 것입니다.

기계어 예제는 x86-64프로세서에서 실행되는 GNU gcc 컴파일러가 만들었읍니다.

그리고 우리는 하드웨어, 기계어, 어셈블리 프로그래밍에 대한 **어떤 경험**도 가정하지 않았습니다.

## 이 책을 읽는 법
컴퓨터 시스템이 어떻게 도는지를 프로그래머의 시각에서 배운 다는 것은 상당히 재밌읍니다.
주 된 이유는 당신이 바로 바로 실행해 볼 수 있기때문입니다.

무엇을 하든지 당신이 무언가 새로운 걸 배울 때, 바로 바로 시도해보고 직접 결과를 확인해보세요.

사실, 우리는 시스템을 배우는 오직 유일한 길은 직접 문제를 다루거나 실제 시스템에 프로그램을 쓰고 운영해보는 것이라고 믿습니다.

위의 이유때문에 새 개념이 소개되면, 하나이상의 연습문제가 바로 본문에 나오게 됩니다.
화이팅하세요. 노오력하세요. ^~^

각각의 연습문제에 대한 해결책(정답)은 각 챕터의 끝자락에 있습니다.

읽을 때마다, 스스로 문제를 해결하려고 노력해보세요.
그리고, 확인해서 올바른 경로로 가고 있는지 제대로 관철하세요.

각 챕터는 각종 난이도를 지닌 homework 문제가 있습니다. (강사 메뉴얼에 homework 정답지 있다는데 헐 따로 구해야 되는건가 아ㅋㅋ)

각각의 homework 문제에 대해 얼마나 노오력을 기울여야하는지 보여드립니다.

- ◆: 몇분만 있으면 뚝딱되는 것. 약간의 프로그래밍이 필요할 수도 있는 문제
- ◆◆: 최대 20분정도 걸리는 것, 코드를 작성하고 테스팅하는데 걸림
- ◆◆◆: 1~2시간 정도 걸리는 것, 많은 코드를 작성하고 테스팅하는데 걸림
- ◆◆◆◆: 랩 과제, 10시간의 노오력이 걸린다.

본문 예제에 있는 코드들은 리눅스에서 gcc로 컴파일하고 직접 테스팅한 코드로 아무 변환 없이 올려놓은 것입니다.

그렇지만 당신의 컴퓨터엔 다른 버젼의 gcc나 다른 컴파일러를 사용하고 있을 수도 있겠죠.
그래서 기계어 코드가 다르게 만들어 질 수 도 있지만 종합적으로 살펴봤을 때, 결국에는 같은 행동을 합니다.

모든 소스코드는 CS:APP 웹 사이트에 올려져 있으며 csapp.cs.cmu.edu로 접속 하실 수 있습니다.

책의 분량이 많아지지 않게 하기위해 책의 몇몇 내용들을 보충하는 자료들을 Web aside를 작성해 놨으며 이는 CS:APP 사이트에 게제돼 있습니다.

## 책 살펴보기
CS:APP 책은 핵심 개념을 포착하기 위해서 고안 된 12챕터로 디자인 되었습니다.

<i>챕터 1: 컴퓨터 시스템 투어</i>는 "hello, world" 프로그램의 생명주기를 추적해서 컴퓨터 시스템에 담긴 주 아이디어와 주제를 소개하는 챕터입니다.

<i>챕터 2: 정보 표현과 조작</i>. 컴퓨터 산수를 다룹니다. 프로그래머에게 영향을 미치는 unsigned(양수 표현 방식)와 two's complement(2의 보수)의 속성을 강조합니다. 

그리고, 숫자가 어떻게 표현되는지와 주어진 단어 크기에 대해 인코딩 할 수있는 값의 범위를 살펴볼겁니다.

signed와 unsigned 숫자들의 캐스팅 효과에 대해서도 알아볼겁니다. 산술연산의 수학적 속성도 다룰겁니다.

초보 프로그래머들은 덧셈(2의 보수) 혹은 두 양수가 음수로 될 수 있다는 사실에 놀랄 때가 있읍니다.

반면, 2의 보수 산술은 정수 산술의 많은 대수적 특성을 충족시킵니다.

때문에 컴파일러는 상수 곱셈을 배열 시프트랑 add로 안전하게 변환 할 수 있습니다.

부울 대수의 원리와 응용을 증명하기 위해 C언어의 비트레벨 연산을 쓸겁니다.

IEEE 부동소수점 형식으로 부동소수점 연산의 수학적 특성과 값을 나타내는 방법을 다룰겁니다.

컴퓨터 산수에 대한 이해도가 견고할 수록, 신뢰할 수 있는 프로그램을 잘 짤 수 있습니다.

예를 들면 프로그래머와 컴파일러는 ```(x<y)```표현식을 ```(x-y < 0)```으로 바꾸지 못합니다. 오버플로우의 가능성 때문에 말이죠.

또한 ```(-y < -x)```의 꼴로도 못 바꿉니다. 2의 음수 표현에서의 음수와 양의 비대칭적인 범위 때문에 말이죠

산술 오버플로우는 프로그래밍 에러와 보안 취약성의 공통점이지만, 프로그래머의 관점에서 컴퓨터 산술의 속성을 다루는 책은 거의 없습니다.

<i>챕터 3: 프로그램의 머신 레벨 표현</i>에서는 C 컴파일러가 만들어낸 x86-64 코드를 읽는 법을 가르칠 겁니다. 

조건문, 루프, 스위치문과 같이 서로 다른 제어 구조로 생성된 기본 패턴을 다룹니다.

또, 프로시저의 구현, 스택 할당 포함, 레지스터 사용 규약, 파라미터 패싱등을 다룰겁니다.

각기 다른 데이터 구조 ㅡ예를 들면, 구조체, unions, 배열 ㅡ가 어떻게 할당되고 접근되는지도 볼겁니다.

정수와 소수점 연산 절차도 다룰거임

머신레벨단계에서 프로그램을 바라볼건데, 왜 이럴거냐면 공통 보안 취약점 ㅡ 버퍼 오버플로우 같은 ㅡ을 프로그래머, 컴파일러, 그리고 운영체제가 줄이기 위해서 무엇을 취할 수 있는지 알아볼거임.

이 챕터에서의 컨셉을 배우고 나면 넌 더 좋은 프로그래머가 될거야, 왜냐면 기계에서 어떻게 프로그램이 도는지를 이해하고 있기 때문이거든

한 가지 확실한 건 포인터에 대해 한 층 더 자세히 알게될거라는 거지

---
이후의 챕터는 그 챕터를 시작할 때 쓰는 것으로 쇼부봄
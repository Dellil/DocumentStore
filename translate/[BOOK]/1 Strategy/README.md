# HEAD FIRST DESIGN PATTERNS
## 1. Strategy Pattern
공부한 날 - 2018.09.09
그 때 상황이 혼자 보기 위함이었으므로 맘에 안 드는 어투, 단어 선택일 수 있음
원서 PDF를 보면서 번역을 했었는데 각종 이미지와 텍스트들이 중구난방으로 배열되어 있고,  1장은 전체적인 책의 흐름을 짚어주기 위한 파트라 내용이 심란함

##  디자인 패턴에 어서와
누군가가 너의 문제를 이미 해결했음, 이 챕터에서 너는 왜(그리고 어떻게) 니가 겪고있는 같은 디자인의 문제점에 대해 다른 개발자의 지식과 수업내용을 활용 할 수 있는 방법을 배울 수 있음.

이 책이 끝나기 전에, 우린 디자인 패턴의 사용 및 이점에 대해 살펴보고, 몇가지 주요 OO디자인에 대해 살펴본후, 한 패턴이 어떻게 작용하는지에 대해 예를 들어서 보겠습니다.

가장 좋은 방법은 패턴을 사용함으로 뇌에 패턴을 기억하게 하는 것이고, 그러면 너의 디자인은 기존의 애플리케이션에 어디에 적용해야 되는지 기억하게 될거임. 코드 재사용은 패턴을 사용함으로 다져진 너의 경험으로 대신 할 수 있어.

1-2 INDEX
- SimUDuck app
- Inheritance(상속)에 대한 Joe의 생각
- Interface는 어때?
- 하나의 변함없는 소프트웨어 개발
- 같은 것으로 부터 변화가 있는 것을 분리하는 법
- Designing the Duck Behaviors (오리 행동 디자인)
- Duck code 테스팅
- 역동적인 행동 세팅
- 캡슐화된 동작에 대한 큰 그림
- HAS-A가 IS-A보다 더 나아! (가지고 있는게 ~는 보다 더 나아!)
- Strategy Pattern(스트래티지 패턴)
- 공유된 패턴 어휘의 힘
- 디자인 패턴은 어떻게 쓰는 거임?
- 너의 디자인 툴박스를 위한 툴
- 연습 솔루션

(그림내용 : 이미지화된 패턴들!은 내 뇌를 통해 내 코드는 디자인 패턴을 통해 개선되었다!)

Index
- 사진 - 그들이 디자인패턴 책에 저것을 넣다니 믿을 수 없어!
- 그래서 그들은 디자인 패턴책에 왜 그것을 넣었나요?

이 책은 누구를 위한 것인가?
만약 이 모든 질문에 예라고 대답할 수 있으면 
1.  두유 노 자바?  (전문가 아니여도 됨)
2.  디자인 패턴을 배우고, 이해하고, 기억하고, 적용하고 싶고, 어떤 디자인을 근본으로하는 OO(Object-Oriented)디자인 종류 원칙을 포함하는가?
3. 무미건조하고, 따분한 학문 적인 강의로 저녁 파티 대화를 갑분싸 시키고 싶니?

그럼 이 책은 널 위한거야!

---

그럼 누가 이 책을 멀리 해야 될까?
1.  자바 완전히 처음이니?
2.  그저 참고서로만 찾고 있니?
3.  엔터프라이즈 설계를 원하니?
4.  무언가 다른 걸 시도하는 걸 두려워하니?

그럼 이 책 보지마!

무슨 생각 하는지 다 알아요
1.  이게 ㄹㅇ루다가 진지한 프로그래밍 책인가?
2.  모든 과정을 그림으로 표현해주나?
3.  실제로 이렇게 배울 수 있나여?

너의 뇌를 이 방법으로 수련 ㄱ
- 더욱 더 집중할수록, 기억력이 떨어질수록 속도를 낮춰라
- 그저 읽지만 마! 멈추고 생각해! 책에서 너에게 질문을 할때, 답을 넘기지마  누군가 정말로 묻고 있다고 상상해봐, 더욱더 깊숙히 니 뇌가 학습하고 기억하는데 좋아질 기회가 있을껄?
- 노트에 적음으로써 학습해
- No Dumb 질문을 읽어 이건 핵심 질문이니까!
- 침대에 눕기전에 마지막에 읽은걸 생각해 아니면 적어도 마지막  도전은 해야겠지
- 물 많이 마셔!
- 그것에 대해 큰 소리로 말해 봐!
- 너의 뇌가 과부화 오는 소리를 들어봐
- 뭔가를 느껴!
- 뭔가를 형상화해!

(여기까지는 책 소개 및 이 책을 보면서 하면 좋은 공부법에 대해 알려주고 있었음)

## 간단한 SimUDuckapp으로 시작
Joe는 높은 퀄리티를 자랑하는 SimUDUCK라는 오리 호수 시뮬레이션을 만드는 회사에서 만들고 있다.

조의 매니저는 아무문제 없을거라 했다.
조는 오리Class에다가 fly메소드만 넣으면 될거라고 생각했다.
근데 뭔가 잘못됐어!

무슨 오리들이 날고있어 너의 그 염병할 농담을 추가시킨거야? 분명 디시같은 곳에서 개드립같은걸 본거지?
무슨 일이 일어난 것인가?

조는 모든 서브클래스에 fly가 추가된다는걸 몰랐어.

조가 슈퍼클래스에 fly행동을 추가했을 때, 또한 조가 이런 짓을 한 건, 오리 서브클래스에 옳지않은 짓을 한거임

조: 그래 내가 실수했어 디자인에 결함이 있네요 왜 그것을 하나의 특징이라고 못 부름? 그냥 커여운데..

조는 유지보수에 관한건 생각 안하고 코드 재사용성만 생각함.

## 상속에 대한 조의 생각
조: 내가 quack메소드를 사용하는 방식에는 러버덕에 항상 fly메소드를 오버라이드할려 했어..  그런데 만약 우리가 나무 미끼 오리를 프로그램에 추가하면? 울지도 날지도 못하겠지?

## 인터페이스 어때?
조는 아마도 상속에 대해 잘 모르는거 같아
그녀석의 메모를 봤을때 the execuives가 오리가 생산되는거를 6달마다 업데이트 하는걸루 원한다구

조는 알면서두 계속 바꾸겠지 그리고 그는 아마도 모든 오리 서브클래스가 프로그램에 추가될때마다 영원히 fly()랑 quack()가 오버라이드 된걸 봐야만 하겠지

그래서 그는 fly 또는 quack를 필요한 오리들만 가질수 있게끔 깔끔하게 정리하는 방법이 필요함

조의 생각: 오리 superclass에 fly()를 빼서 flyable 인터페이스에다가 fly()메소드를 끼얹는거야 이 방법은 날 수있는 오리들에게만 flyable인터페이스를 implement해서 fly()메소드를 갖게하는거지 ㅎ; 그리고 난 빨리 quackable을 만들수 있겠지 모든 오리들이 울수있는건 아니니까 후훟..

저건 가장 나쁜 생각이야 넌 코드중복에 대한 답을 내놓을수잇어? 몇몇 메소드들을 오버라이드 할려는 생각은 나쁜것이야 fly행동을 얼마나 넣어야 되는지 알 수 있음? 아님 48마리의 나는 모든 오리 서브 클래스에다가 넣어야 할 수도 있다구?

## 내가 조라면 어떻게 했을 것인가
우리는 모든 서브클래스들이 날거나 꽥꽥 우는 행동을 갖고 있는게 아닌걸 알 수 있어. 그래서 상속은 올바른 정답이 아니야 하지만 superclass에 flyable 또는 quackable interface를 implements하면 문제의 일부분을 해결 할 수 있어 (근데 고무오리는 날지 않지?) 완전하게 그것들의 행동에 대한 코드 재활용을 파괴됐지 그래서 그건 어려움을 겪어내게 만들어서 유지보수의 악몽이 다가오지ㅠㅠ

그리고 물론 날 수있는 오리들 중에서도 나는 한가지 행동만 있을수도 있지

우린 구식 방법의 해결책을 찾아낼거임 물론 OO(객체지향적[Object-Oriented])소프트웨어 디자인 원칙을 적용해서.

## 문제해결
ㅋㅋ 우린 inheritance(상속) 사용해도 소용없단걸 알았음.

서브클래스의 오리 행동들이 계속해서 변화할경우, 모든 서브클래스에 그들의 행동을 갖고있는건 옳지않은 일임.

자바에는 인터페이스 제외 구현 코드가 없으므로 행동들을 수정할 필요가 있음. 어쩔수 없이 모든 서브클래스들에다가 행동들을 찾아내어 변경해서 정의해야겠지.

아마도 새로운 버그를 발견할거임 ㅋㅋ

다행히, 이 상황에 대한 디자인 원칙이 있음

디자인 원칙 : 달라지는 부분을 달라지지않는 부분으로부터 분리하셈

다른 말로는, 새로운 요구사항이 필요하다 말하면은 너의 코드중 일부를 변경해야됨 ㅋㅋ

근데 너도 (method들)행동을 빼내고, 코드가 수정되지 않은 모든 클래스로부터 분리할 필요가 없다는걸 알게될걸?

여기 이 원칙에 대해 다른말로 풀어보자면 "부품들을 변화및 캡슐화시켜"라는 말이야

이 방법은 나중에 변경할 가능성이 있는 부품에 영향을 미치지 않고 다양한 부품을 변경하거나 생성할수 있지..

이 개념은 간단한걸? 그래서 모든 디자인 패턴의 근본이 됨.

모든 패턴들은 시스템의 일부를 변경하는 방법을 제공해서 다른 모든 부분과 독립적으로 됨

ㅇㅋ 이제 덕 클래스로부터 오리의 행동들을 뺄 시간이야

다양성을 갖고있고 캡슐화하여 너의 코드에 영향을 적게 줌!

결과는 뭐냐구? 니 시스템에 의도하지 않은 결과가 보다 적게 나타나고 유연성을 갖추게된다구!

## 바뀌는 곳과 바뀌지 않는 곳 구분하기
어디서 시작해야될까? 우리가 말할 수 있는 건 fly() quack()를 포함한 문제 이외의 오리 클래스가 잘 동작하고 다른 부품들이 바뀌는 부분은 없음 그것뿐임.

(사진들)

우린 두개의 정의된 클래스(종합적으로 duck을 제외하고) 하나는 fly이고 하나는 quack지. 각각 정의된 클래스들은 그들 각자의 행동을 구현하겠지.

하나의 클래스엔 날수있는것과 날수 없는것을 implements하겠지

또, 하나의 클래스엔 우는것을, 또 하나엔 squeaking을 마지막 하나엔 silence(침묵)을 implements하겠지
이제 우린 fly()와 quack()가 오리마다 다른 오리클래스인걸 알게되었음

그들의 행동을 오리클래스로부터 분리하기위해서, 우린 두개의 메소드들을 오리 클래스에 빼와서 각각 새롭게 정의된 새로운 오리 클래스를 만들었지.

오리 클래스는 여전히 모든 오리들의 슈퍼클래스야 하지만 우는거와 나는 행동을 빼내서 다른 클래스 구조에 넣었어.

이제 나는거(fly)와 우는건(quacking) 각각 자신만의 클래스에 가지고 있음 ㅋ

즉, 오리 행동엔 다른 행동들이 구현되고 있다.

## 오리 행동들 디자인하기
그래서 어떻게 우리가 클래스의 집합에서 fly와 quack 행동들을 구현하죠?
우린 인터페이스를 사용하여 각각의 행동들을 구현할거에요!
그리고 각각 구현된 행동들은 그것들의 인터페이스를 구현하겠죠

## DUCK 행동 통합
핵심은 Duck에 정의된 quacking과 flying methods를 사용하는 대신, 오리 한마리마다 quacking과 flying 동작을 위임받는다.

## 설명충 들어간다!
1.  먼저 flyBehavior라고 불리는 duck class와 quackBehavior라고 불리는 duck class로 부터 두개의 인스턴스 변수를 추가할거야, 
그것들은 인터페이스 형식으로 정의되어 있지 ( 즉 구체적으로 구현이 안 되어있다 이말이야.)
각각 duck 오브젝트는 다형성을 이용하여 원하는 특정 동작을 참조해(flywithwings, squeak, 등등).
또한 우리는 duck class(그리고 모든 서브클래스들)에서 fly와 quack 메소드들을 삭제 할거야 왜냐하면 이 행동들은 flyBehavior & quackBehavior 클래스에 구현되었잖아?
대신, 우리는 duck class안에 있는 fly&quack 와 유사한 메소드들로 바꿀거야. performFly()와 performQuack()라고 불리는 메소드들이지.
넌 담에 이것들이 어케 작동하는지 볼 수 있을거야.
2. performQuack() implement하기
``` java
public class Duck {
	QuackBehavior quackBehavior;
	//more
	public void performQuack() {
		quackBehavior.quack();
	}
}
```
아주 간단하지 응? 오리가 울기 위해서는 quackBehavior를 참조하여 quack만 소환하면 되니까 말이야.
이 부분에선 우리가 무슨 종류의 오브젝트인지 신경 쓸 필요가 없다는 거야. 왜냐면 quack거리는 방법을 알고 있잖아

## 더 많은 통합
3. 그래 flyBehavior와 quackBehavior 인스턴스 변수들을 어떻게 셋팅하는지 걱정할 시간이 그럼 MallardDuck클래스를 살펴볼까?
``` java
public class MallardDuck extends Duck {
	public MallardDuck() {
		quackBehavior = new Quack();
		flyBehavior = new FlyWithWings();
	}
}
```

짬깐만요 생성자에다가 Quack 구현한 클래스의 인스턴스를 정의했는데요?
ㄴ 좋은 지적임 ㅎ 나중에 책에서 패턴 수정해서 문제를 해결할수있어

### 캡슐화된 행동을 큰 그림으로 바라보자.
그래 우린 오리 디자인에 대해 깊이 연구했어, 다시 돌아와서 숨쉬고 큰 그림을 봐!
아래의 그림은 우리가 뜯어고친(재작업된) 클래스 구조야

네가 기대하고 있는것들은, 우리가 다 가지고 있음 ㅋ
ducks들은 Duck class를 extende하고, fly하는 행동을 FlyBehavior에다가 구현해놨고 quack하는 행동을 QuackBehavior에다가 구현해놨지.

또한, 우리는 사물들을 조금 다르게 묘사하기 시작했다는 것에 대하여 관심을 가져야해.

duck behaviors(오리 행동을)을 행동의 집합으로 생각하지말고, 알고리즘의 집합으로 생각해보자고!
SimUDuck 디자인에 대해 생각 해봐, 알고리즘들은 오리들의 행동에 해당 되지.

하지만 우린 다른 상태에서 상태를 계산하는 구현하는 일련의 클래스들에다가 같은 기법으로 쉽게 사용할 수 있음.

주의깊게 봐야될 것은 클래스들 사이의 숨겨져 있는 relationships(관계)에 대해서야.

실은, 펜을 쥐고 적절한 관계도를 사용해서 클래스 다이어그램에다가 각각 화살표를 추가해보면 이래
(다이어그램 관계도)
클라이언트는 flying과 quacking에 캡슐화된 알고리즘 가족을 사용하지.

각각의 행동들을 알고리즘들의 집합으로 생각해.
이 알고리즘 들은 교환이 가능해(바꿔쓰기 가능)

## “A는 B이다” 보다 “A는 B가 있다”가 나을 수 있어!
a는 b이다의 관계는 흥미로운 관계야 각각의 오리들이 flyBehavior(나는 행동)과 quackBehavior(우는 행동) 통해 flying과 quacking을 대표했지.

네가 두개의 클래스들을 합쳐서 구성요소들로 사용한다면

그들의 행동을 상속하는 대신에, 오리들은 올바른 행동 오브젝트로 구성되어 행동을 취할수 있겠지.

이것은 중요한 기법이야 실은, 우리가 사용해온 우리들의 제 3 디자인 원칙이야.
### 디자인 원칙: 상속에 대한 구성요소들의 우선순위 지정
네가 본것 처럼, 구성을 사용함으로 더 많은 유연성을 줄 수있어,

알고리즘집합을 클래스들에 넣어서 캡슐화 할 수 있을뿐만 아니라 컴파일 할 개체가 올바른 동작(Behavior)인터페이스를 구현하고있으면 런타임도중에 동작(Behavior)들을 변경가능하다구!

구성(composition)은 많은 디자인패턴에 사용되고 있고, 너는 책 전반에 걸쳐서 장,단점을 훨씬 더 많이 찾아볼 수 있을거야.

## 마스터와 제자
마스터: 메뚜기야, Object-Oriented방식에 대해 알게 된걸 말해주련?

제자: 맛-스터.. 객체지향 방식의 약속은 재사용이란걸 배웠습니다.

마스터: 계속 말해보렴.

제자: 맛-스터..inheritance를 통해 모든 좋은 것들을 재사용 할 수 있어요. 마치 숲속에서 대나무들을 빨리 자르는 것처럼 개발 시간을 단축 할 수 있어요.

마스터: 메뚜기야..개발이 끝나기 전 과 후 언제 시간을 더 많이 쏟아붓느냐..

제자: 답은 개발 후 입니다 맛-스터.. 우린 항상 소프트웨어를 초기개발 할 때 보다, 유지보수하는데 시간이 더 많이 듭니다.

마스터: 그래서 메뚜기야.. 유지보수와 확장성에 대해서 코드를 재사용 하는 노력을 기울여야 되니?

제자: 맛-스터.. 저는 이것에 진실이 있다고 믿고 있읍니다..

마스터: ㅉㅉ 니새낀 한참 멀었구나 상속에 대해 한참 더 생각해보거라,  inheritance(상속)은 문제가 있고, 그리고 다른 방법으로 재사용 될 수 있다.

## 디자인 패턴에 대해..
넌 첫번째 디자인 패턴-Strategy Pattern(스트래티지 패턴)-을 응용했어.
맞아, SimUDuck앱에다가 Strategy 패턴을 재작업했지.
스트래티지 패턴 덕분에, 시뮬레이터는 어떠한 변화가 오더라도 늘 준비가 되있을거야.
우리는 너가 스트래티지 패턴을 적용시키기 위해 먼 길을 오도록 만들어놨어

이 패턴에 대해 형식적으로 정의해 놓은걸 봐바

스트래티지 패턴은 **알고리즘의 집합에 대해 정의하고, 각각을 캡슐화하고, 상호 교환이 가능하게 하도록 하는 패턴**이다.
스트래티지를 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.

## 디자인 패턴 어떻게 쓰는데
명심해
추상화, 유전, 다형성과 같은 개념이 당신을 좋은 객체지향 디자이너로 만들지는 않는다. 한 디자인 전문가는 어떻게 하면 유지 가능하고 변화에 대처할 수 있는 유연한 디자인을 만들 수 있을지에 대해 생각한다.

## 내 디자인 툴박스를 위한 툴들
넌 첫장을 거의 통과햇음 ㅊㅊ 이미 OO도구상자에 몇가지 도구를 넣었으니 2장으로 넘어가기 전에 목록을 작성해 볼까?

OO Basies (객체지향의 기본들)
- 추상화(Abstraction)
- 캡슐화(Encapsulation)
- 다형성(Polymorphism)
- 상속(Inheritance)

### OO Prineciples (객체지향의 원칙들)
변화하는 요소들은 캡슐화한다.
상속(inheritance)을 넘어서는 구성(composition)을 활용하라
구현이 아닌 인터페이스에 초점을맞춰서 프로그래밍 하기

  

## OO Patterns (객체지향 패턴)

Strategy 스트래티지 - 스트래티지 패턴은 알고리즘의 집합에 대해 정의하고, 각각을 캡슐화하고, 상호 교환이 가능하게 하도록 하는 패턴이다.
스트래티지를 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.

## Bullet Points
객체지향 기본을 아는 것 만으로 너를 좋은 객체지향 디자이너로 만들어 주지 않는다.

좋은 객체지향 디자인은 재사용, 확장성, 유지보수성이 뛰어난 디자인이다.

패턴들은 너에게 좋은 객체지향 디자인퀄리티로 시스템을 구축하는 방법을 보여줌!

패턴은 입증된 객체지향 경험이다.

패턴은 너에게 코드를 주지않는다. 그저 디자인 문제에 대해 일반적인 해결책을 제공해준다. 넌 애플리케이션의 특정 영역안에다가 그걸 적용하면 되는거임.

패턴은 발명되지 않았고, 발견되었다.

많은 패턴과 원칙들은 소프트웨어의 변화에 대한 문제를 다룬다.

대부분의 패턴은 시스템 일부분이 다른 모든 부분과 독립적으로 변화할수있게 한다.

우리는 시스템에서 구성요소가 자주 바뀌는 부분은 캡슐화를 할거임

패턴은 다른 개발자와의 커뮤니케이션 가치를 극대화할 수 있는 공유된 언어를 제공함.
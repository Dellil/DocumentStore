회사에서 대충 정리한 것의 후환이 닥쳤다.

## Factory
문제상황)
피자를 주문할때 피자 종류가 하나면은 간단하게 리턴할 수 있는데,

피자 종류가 여러개면은 코드가 더러워짐(if문을 통해서 피자종류를 구별하는 경우)

팩토리 패턴은 이런 문제를 해결할 수 있음

객체를 생성하는 부분을 팩토리라는 클래스로 넘겨서 만듦

팩토리는 여러 종류가 있음
- 팩토리 메소드와 
- 추상 팩토리가 있음

> 팩토리 메소드를 쓰기 위한 문제 상황

피자가게는 분점을 냈음. 하지만 가게 끼리의 내는 맛이 다름. 이를 일치시킬 방법이 필요함
팩토리의 거기다가 뚝딱

모든 팩토리 패턴은 객체생성을 캡슐화
- 서브클래스에서 어떤 클래스를 만들지 결정함으로써 캡슐화함
what does mean?
컨셉 - 객체 생성을캡슐화

팩토리 메소드를 사용 함으로 의존성 뒤집기 원칙이 적용됨

추상화된 것에 의존하게 됨

## Singleton
생성자를 접근제어자로 제어해서 인스턴스 하나만 만듦

해당 객체를 동시에 쓸때, 그게 문제가 일어날 경우에 싱글톤을 쓴다.

싱글톤을 쓸때는 그 객체의 인스턴스가 쓰이는 범위가 한 군데일 경우임

아무튼 그럼

왜 db는 어플리케이션에 접근할때 인스턴스를 하나만 주면은,

서로 다른 인스턴스가 접근했을때 누구의 인스턴스에게 권한을 허용해주냐는거임

그래서 그럼

## Command
pptx 자료밖에 없음
~~*(자료 보존 필요성을 뼈저리게 느꼈다)*~~

## Adapter
객체를 래퍼로 감싼다.
그렇게 해서 실제와 다른 인터페이스를 가진것처럼 보이도록 할 계획임

기존에 사용하고 있던 시스템과 업체에서 제공한 클래스의 인터페이스가 서로 다름
그러므로 중간에 어댑터를 사용하여 끼워맞춤

클라이언트는 타겟 인터페이스에 맞게 구현되어 있음
어댑터는 타겟인터페이스를 구현하며 어댑티 인스턴스가 들어있음

> 클라이언트가 어댑터를 사용하는 방법

- 클라이언트에서 타겟 인터페이스를 사용하여 메소드를 호출함으로써 어댑터에 요청
- 어댑터에서는 어댑티 인터페이스 사용으로 요청을 어댑터에 대한 메소드 호출로 변환
- 클라이언트에서는 호출 결과를 받지만 중간에 어댑터가 있는지는 알지못함

> 어댑터 패턴 - 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 인터페이스로 변환함

어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸수있습니다.

> 다이어그램 설명

- 클라이언트에서는 타겟인터페이스만 앎
- 어댑터에선 타겟인터페이스 구현
- 어댑터는 어댑티로 되어있음
- 모든 요청은 어댑티에게 위임

### 퍼사드
많은 인터페이스를 단순화시킴.

1. 홈 씨어터 시스템용 퍼사드를 만듦
2. 퍼사드 클래스 에서는 홈 씨어터 구성요소들을 하나의 서브시스템으로 간주
3. 클라이언트 코드는 서브시스템이아닌 퍼사드의 메소드를 호출
4. 퍼사드를 쓰더라도 서브시스템에는 여전히 직접 접근가능

어댑터와 퍼사드의 차이점은 용도에 있음

어댑터패턴은 인터페이스를 변경해 클라이언트에서 필요로 하는 인터페이스로 적응시키는 용도

퍼사드는 서브시스템에 대한 간단한 인터페이스 제공 용도

> 퍼사드 패턴 - 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스 제공

> 최소 지식 원칙 - 정말 친한 친구하고만 얘기하라

**핵심정리**

기존 클래스를 사용하려는데 인터페이스 안 맞으면 어댑터 사용

큰 인터페이스, 여러 인터페이스르 단순화 시키거나 통합시키는 경우에는 퍼사드 사용

어댑터는 인터페이스를 클라이어트에서 원하는 인터페이스로바꿔주는 역할

퍼사드는 클라이언트 서브시스템터 구현할 때, 타겟인터페이스과 분리

어댑 크기와 구조에따라 코딩해야할 분량이 결정됨

퍼사드는 서브시스템을 가지고 퍼사드를 만들고, 실제 작업은 그 서브클래스에게 맡김

한 서브시스템에다가 퍼사드 여러개 만들어도됨

## Template Method
템플릿메소드에서는 각 단계의 알고리즘을 정의하며, 그중 한개 이상의 단계가 서브클래스에 의해 제공됨

> 템플릿메소드 패턴 - 메소드에서 알고리즘의 골격을 정의함. 알고리즘의 여러 단계중 일부는 서브클래스에서 구현 가능.
템플릿 메소드를 이용하면 알고리즘의 구조는 유지하면서 서브클래스에서 특정단계의 알고리즘을 재정의할수있다.

  

다이어그램 -
템플릿메소드에서 알고리즘 구현할때 primitiveOperation1과 2 활용, 알고리즘 자체는 분리되어있음

Abstgractclas에 템플릿메소드있음

abstract메소드로 선언된 단계들이 템플릿메소드에서 활용됨

Concreteclass는 여러개가 있을수있음. 각 클래스에서느 템플릿메소드에서 요구하는 모든단계들 제공

abstract로 선언되는 단계들은 concreteclass에서 구현함. templatemethod에서는 이런 메소드르을 호출해서 작업을처리함

> 할리우드 원칙 - 먼저 연락 ㄴㄴ, 저희가 연락드림

**핵심정리**

- 템플릿메소드는 코드재사용에 크게 도움이됨
- 템플릿메소드가 들어있는 추상클래스에서는 구상메소드,추상메소드,후크정의가능
- 추상메소드는 서브클래스에서 구현함
- 후크는 추상클래스에 들어있는, 아무일도 하지않거나 기본행동응ㄹ 정의하는 ㅁ소드로, 서브클래스에서 오버라이드 가능
- 헐리우드원칙에 의하면 저수준 모듈을 언제 어떻게 호출할지는 고수준 모듈에서 결정하는 것이 좋음

템플릿메소드 패턴은 실전에서도 꽤 자주 쓰이지만 반드시 교과서적인 방식으로 적용되진않음

스트래티지패턴과 템플릿메소들패턴은 모두 알고리즘을 캡슐화하는 패턴이지만 전자에서는 구성을, 후자에서는 상속을 이용함

팩토리메소드는 특화된 템플릿메소드패턴임